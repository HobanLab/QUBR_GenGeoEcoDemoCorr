LM_fixed_field_data_processed_sf_quad
?quadscheme
#plotting the alternative model
plot(effectfun(PPM1, "dist_near_river_buffer_LM_inverse", se.fit = TRUE), main = "Distance to River",
ylab = "Quercus brandegeei Trees", xlab = "Distance to River", legend = FALSE)
plot(as.im(dist_near_river_buffer_LM_inverse))
#turning the shapefile of the tree points into a quadrature scheme to be able to
LM_fixed_field_data_processed_sf_quad <- quadscheme(LM_fixed_field_data_processed_sf)
plot(as.im(dist_near_river_buffer_LM_inverse))
plot(p.km)
plot(starbucks.km)
LM_fixed_field_data_processed_sf
LM_fixed_field_data_processed_sf
plot(pop.lg.km)
starbucks.km
as.ppp(LM_fixed_field_data_processed_sf)
as.ppp(LM_fixed_field_data_processed_sf)
s <- st_read("/Users/chewbecca/Downloads/data (1)/Walmarts.shp")
p    <- as.ppp(s)
p.km <- rescale.ppp(p, 1000)
marks(p.km)  <- NULL
Window(p.km) <- w.km
s <- st_read("/Users/chewbecca/Downloads/data (1)/MA.shp")
s    <- st_read("MA.shp")
w    <- as.owin(s)
w.km <- rescale.owin(w, 1000)
s <- st_read("/Users/chewbecca/Downloads/data (1)/Walmarts.shp")
p    <- as.ppp(s)
p.km <- rescale.ppp(p, 1000)
marks(p.km)  <- NULL
Window(p.km) <- w.km
img     <- rast("log_pop_sqmile.tif")
plot(p.km)
p.km
pop.km
plot(pop.km)
river_LM_trans_point_raster
dist_near_river_buffer_LM_inverse
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf ~ st_rasterize(dist_near_river_buffer_LM_inverse))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf ~ st_rasterize(dist_near_river_buffer_LM_inverse)))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf ~ st_rasterize(dist_near_river_buffer_LM_inverse)))
st_rasterize(dist_near_river_buffer_LM_inverse)
st_rasterize(river_LM_trans)
raster(river_LM_trans)
pop.km
as.im(raster(river_LM_trans))
raster(river_LM_trans)
as.im(river_LM_trans)
raster(river_LM_trans)
raster(river_LM_trans)
river_LM_trans
as.im(river_LM_trans)
plot(river_LM_trans)
install.packages("geostatsp")
library(geostatsp)
as.im.RasterLayer(river_LM_trans)
asImRaster(river_LM_trans)
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf ~ as.imRaster(river_LM_trans)))
library(tmaptools)
library(tmaptools)
fixed_field_data_processed <- read.csv("./analyses/fixed_field_data_processed.csv") #imports the csv created from analyzing_morpho_data_cleaned.R
im(dist_near_river_buffer_LM_inverse)
dist_near_river_buffer_LM_inverse
as.raster(river_LM_trans)
raster(river_LM_trans)
im(raster(river_LM_trans))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf ~ im(raster(river_LM_trans)))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf ~ im(raster(river_LM_trans))))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf ~ im(raster(river_LM_trans))))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf) ~ im(raster(river_LM_trans)))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf), covariate = im(raster(river_LM_trans)))
PPM1
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf), trend = ~im(raster(river_LM_trans)), covariates = im(raster(river_LM_trans)))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf), trend = ~im(raster(river_LM_trans)), covariate = im(raster(river_LM_trans)))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf), trend = raster(river_LM_trans), covariate = im(raster(river_LM_trans)))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf), trend = ~list(im(raster(river_LM_trans))), covariate = im(raster(river_LM_trans)))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf), trend = ~im(raster(river_LM_trans)), covariate = list(im(raster(river_LM_trans)))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf), trend = ~im(raster(river_LM_trans)), covariate = list(im(raster(river_LM_trans))))
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf), trend = ~im(raster(river_LM_trans)), covariate = list(im(raster(river_LM_trans))))
plot(im(raster(river_LM_trans)))
im
im
as.im(raster(river_LM_trans)
tmaptools::as.im(dist_near_river_buffer_LM_inverse)
as.im(dist_near_river_buffer_LM_inverse)
#this did not work
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf), trend = ~ as.im(dist_near_river_buffer_LM_inverse), covariate = as.im(dist_near_river_buffer_LM_inverse))
plot(as.im(dist_near_river_buffer_LM_inverse))
#this did not work
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf) ~ as.im(dist_near_river_buffer_LM_inverse))
pop.km
as.im(dist_near_river_buffer_LM_inverse)
Mpop <- ppm(p.km ~ pop.km)
Mo   <- ppm(p.km ~ 1)
Mpop
p.km
as.ppp(LM_fixed_field_data_processed_sf)
pop.km
as.im(dist_near_river_buffer_LM_inverse)
pop
ppm(p.km ~ pop)
ppm(p.km ~ pop)
p.km
p
ppm(p ~ pop)
PPM1 <- ppm(Q = as.ppp(LM_fixed_field_data_processed_sf), trend = ~as.im(dist_near_river_buffer_LM_inverse), data = NULL, interaction = NULL)
PPM1 <- ppm(Q = as.ppp(LM_fixed_field_data_processed_sf), trend = ~as.im(dist_near_river_buffer_LM_inverse),
data = NULL)
PPM1 <- ppm(Q = as.ppp(LM_fixed_field_data_processed_sf), trend = ~as.im(dist_near_river_buffer_LM_inverse))
#this did not work
PPM1 <- ppm(as.ppp(LM_fixed_field_data_processed_sf) ~ as.owin(as.im(dist_near_river_buffer_LM_inverse)))
PPM1
PPM1 <- ppm(Q = as.ppp(LM_fixed_field_data_processed_sf), covariates = list(as.im(dist_near_river_buffer_LM_inverse)=as.im(dist_near_river_buffer_LM_inverse)))
PPM1 <- ppm(Q = as.ppp(LM_fixed_field_data_processed_sf), covariates = list(as.im(dist_near_river_buffer_LM_inverse)==as.im(dist_near_river_buffer_LM_inverse)))
PPM1
list(as.im(dist_near_river_buffer_LM_inverse)==as.im(dist_near_river_buffer_LM_inverse))
list(as.im(dist_near_river_buffer_LM_inverse)=as.im(dist_near_river_buffer_LM_inverse))
list(as.im(dist_near_river_buffer_LM_inverse), as.im(dist_near_river_buffer_LM_inverse))
list(as.im(dist_near_river_buffer_LM_inverse))
PPM1 <- ppm(Q = as.ppp(LM_fixed_field_data_processed_sf), covariates = list(as.im(dist_near_river_buffer_LM_inverse))) #as.im(dist_near_river_buffer_LM_inverse))
PPM1
dist_near_river_buffer_LM_inverse_im <- as.im(dist_near_river_buffer_LM_inverse)
PPM1 <- ppm(Q = as.ppp(LM_fixed_field_data_processed_sf) ~ dist_near_river_buffer_LM_inverse_im) #as.im(dist_near_river_buffer_LM_inverse))
PPM1
#null hypothesis, no change in the trend of the points
PPM0 <- ppm(as.ppp(LM_fixed_field_data_processed_sf) ~ 1)
PPM0
#using a likelihood ratio test to compare the alternative and null models
anova(PPM0, PPM1, test="LRT")
#plotting the alternative model
plot(effectfun(PPM1, "dist_near_river_buffer_LM_inverse", se.fit = TRUE), main = "Distance to River",
ylab = "Quercus brandegeei Trees", xlab = "Distance to River", legend = FALSE)
#plotting the alternative model
plot(effectfun(PPM1, "dist_near_river_buffer_LM_inverse_im", se.fit = TRUE), main = "Distance to River",
ylab = "Quercus brandegeei Trees", xlab = "Distance to River", legend = FALSE)
#creating the image of the distance to river stars
dist_near_river_buffer_LM_inverse_im <- as.im(dist_near_river_buffer_LM_inverse)
#Alternative hypothesis, seeing if the distance to the river's edge influences the tree point placement
PPM1 <- ppm(Q = as.ppp(LM_fixed_field_data_processed_sf) ~ dist_near_river_buffer_LM_inverse_im) #as.im(dist_near_river_buffer_LM_inverse))
PPM1
#null hypothesis, no change in the trend of the points
PPM0 <- ppm(as.ppp(LM_fixed_field_data_processed_sf) ~ 1)
PPM0
#using a likelihood ratio test to compare the alternative and null models
anova(PPM0, PPM1, test="LRT")
#plotting the alternative model
plot(effectfun(PPM1, "dist_near_river_buffer_LM_inverse_im", se.fit = TRUE), main = "Distance to River",
ylab = "Quercus brandegeei Trees", xlab = "Distance to River", legend = FALSE)
tree.dist <- as.matrix(dist(cbind(fixed_field_data_processed_NN_UTM$X.1,
fixed_field_data_processed_NN_UTM$Y))) #making a matrix of the distances between trees
View(tree.dist)
tree.dist.inv <- 1/tree.dist #makes it so closer trees are higher in the matrix
diag(tree.dist.inv) <- 0 #makes so trees have a 0 distance with themselves
View(tree.dist.inv)
Moran.I(fixed_field_data_processed_NN_UTM$Canopy_short, tree.dist.inv)
tree.dist.inv[is.infinite(tree.dist.inv)] <- 0
tree.dist.inv
View(tree.dist.inv)
tree.dist.inv <- 1/tree.dist #makes it so closer trees are higher in the matrix
diag(tree.dist.inv) <- 0 #makes so trees have a 0 distance with themselves
s.infinite(tree.dist.inv
)
is.infinite(tree.dist.inv)
is.infinite(tree.dist.inv) == T
which(is.infinite(tree.dist.inv))
tree.dist.inv[tree.dist.inv]
1/54402
1/1000000000000000
tree.dist <- as.matrix(dist(cbind(fixed_field_data_processed_NN_UTM$X.1,
fixed_field_data_processed_NN_UTM$Y))) #making a matrix of the distances between trees
tree.dist.inv[is.infinite(tree.dist.inv)] <- 0 # solves problem presented by duplicated GPS points for trees that were very close to one another
Moran.I(fixed_field_data_processed_NN_UTM$Canopy_short, tree.dist.inv)
tree.coord.matrix <- as.matrix(cbind(fixed_field_data_processed_NN_UTM$X.1,
fixed_field_data_processed_NN_UTM$Y))
tree.coord.matrix <- as.matrix(cbind(fixed_field_data_processed_NN_UTM$X.1,
fixed_field_data_processed_NN_UTM$Y))
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn <- knearneigh(tree.coord.matrix, k = 1) #I have playing around with the k, trying to include all or half of the trees for example
#turns knn into neighbors list
nb <- knn2nb(knn, row.names = NULL, sym = FALSE)
#assigning weights to each neighbor, W style assigns weight to be 1/# of neighbors
lw <- nb2listw(nb,zero.policy=TRUE, style="W")
#checks the neighbor weights for the first tree
lw$weights[1]
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn <- knearneigh(tree.coord.matrix, k = 5) #I have playing around with the k, trying to include all or half of the trees for example
#turns knn into neighbors list
nb <- knn2nb(knn, row.names = NULL, sym = FALSE)
#assigning weights to each neighbor, W style assigns weight to be 1/# of neighbors
lw <- nb2listw(nb,zero.policy=TRUE, style="W")
#checks the neighbor weights for the first tree
lw$weights[1]
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn <- knearneigh(tree.coord.matrix, k = 1) #I have playing around with the k, trying to include all or half of the trees for example
#turns knn into neighbors list
nb <- knn2nb(knn, row.names = NULL, sym = FALSE)
#assigning weights to each neighbor, W style assigns weight to be 1/# of neighbors
lw <- nb2listw(nb,zero.policy=TRUE, style="W")
#checks the neighbor weights for the first tree
lw$weights[1]
#creating lags, which computes the average neighboring short canopy axis for each tree
fixed_field_data_processed_NN_UTM$lag.canopy.short <- lag.listw(lw, fixed_field_data_processed_NN_UTM$Canopy_short)
# Create a regression model
M <- lm(lag.canopy.short ~ Canopy_short, fixed_field_data_processed_NN_UTM)
# Plot the lagged variable vs. the variable
ggplot(data=fixed_field_data_processed_NN_UTM, aes(x=Canopy_short, y=lag.canopy.short))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Short Canopy Axis")+
ylab("Lagged Short Canopy Axis")
#computing the moran's I statistic
moran(fixed_field_data_processed_NN_UTM$Canopy_short, listw = lw, n = length(nb), S0 = Szero(lw))
#assessing statistical significance
MC<- moran.mc(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 999)
MC
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn <- knearneigh(tree.coord.matrix, k = 639) #I have playing around with the k, trying to include all or half of the trees for example
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn <- knearneigh(tree.coord.matrix, k = 500) #I have playing around with the k, trying to include all or half of the trees for example
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn <- knearneigh(tree.coord.matrix, k = 550) #I have playing around with the k, trying to include all or half of the trees for example
fixed_field_data_processed_NN_UTM$X.1
tree.dist
#assessing statistical significance
MC<- moran.mc(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 999)
MC
plot(MC, main="", las=1)
MC$p.value
#assessing statistical significance
MC<- moran.mc(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 999)
plot(MC, main="", las=1)
# Plot the lagged variable vs. the variable
ggplot(data=fixed_field_data_processed_NN_UTM, aes(x=Canopy_short, y=lag.canopy.short))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Short Canopy Axis")+
ylab("Lagged Short Canopy Axis")
plot(MC, main="", las=1)
fixed_field_data_processed_NN_UTM
ggplot()+
geom_sf(river_LM_trans)+
geom_sf(data=fixed_field_data_processed_NN_UTM)
ggplot()+
geom_sf(data=river_LM_trans)+
geom_sf(data=fixed_field_data_processed_NN_UTM)
ggplot()+
geom_sf(data=river_LM_trans)+
geom_sf(data=LM_fixed_field_data_processed)
ggplot()+
geom_sf(data=river_LM_trans)+
geom_sf(data=LM_fixed_field_data_processed, aes(col=Canopy_short))+
scale_color_continuous()
ggplot()+
geom_sf(data=river_LM_trans)+
geom_sf(data=LM_fixed_field_data_processed, aes(col=Canopy_short))+
scale_color_viridis_b()
ggplot()+
geom_sf(data=river_LM_trans)+
geom_sf(data=LM_fixed_field_data_processed, aes(col=Canopy_short))+
scale_color_viridis_c()
river_LC_trans
ggplot()+
geom_sf(data=river_LC_trans)+
geom_sf(data=LC_fixed_field_data_processed, aes(col=Canopy_short))+
scale_color_viridis_c()
ggplot()+
geom_sf(data=river_LC_trans)+
geom_sf(data=LC_fixed_field_data_processed, aes(size=Canopy_short))
ggplot()+
geom_sf(data=river_LC_trans)+
geom_sf(data=LC_fixed_field_data_processed, aes(size=Canopy_short), alpha = .3, color = "gray")
ggplot()+
geom_sf(data=river_LC_trans)+
geom_sf(data=LC_fixed_field_data_processed, aes(size=Canopy_short), alpha = .5, color = "gray")
ggplot()+
geom_sf(data=river_LC_trans)+
geom_sf(data=LC_fixed_field_data_processed, aes(size=Canopy_short), alpha = .5, color = "red")
ggplot()+
geom_sf(data=river_LC_trans)+
geom_sf(data=LC_fixed_field_data_processed, aes(size=Canopy_short), alpha = .5, shape = 6)
ggplot()+
geom_sf(data=river_LC_trans)+
geom_sf(data=LC_fixed_field_data_processed, aes(color=Canopy_short), alpha = .5) +
scale_color_viridis_c()
ggplot()+
geom_sf(data=river_LC_trans)+
geom_sf(data=LC_fixed_field_data_processed, aes(color=Canopy_short, size = Canopy_short), alpha = .5) +
scale_color_viridis_c()
ggplot()+
geom_sf(data=river_LC_trans)+
geom_sf(data=LC_fixed_field_data_processed, aes(color=DBH_ag, size = DBH_ag), alpha = .5) +
scale_color_viridis_c()
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn <- knearneigh(tree.coord.matrix, k = 1) #I have playing around with the k, trying to include all or half of the trees for example
#turns knn into neighbors list
nb <- knn2nb(knn, row.names = NULL, sym = FALSE)
#assigning weights to each neighbor, W style assigns weight to be 1/# of neighbors
lw <- nb2listw(nb,zero.policy=TRUE, style="W")
#checks the neighbor weights for the first tree
lw$weights[1]
#creating lags, which computes the average neighboring short canopy axis for each tree
fixed_field_data_processed_NN_UTM$lag.canopy.short <- lag.listw(lw, fixed_field_data_processed_NN_UTM$Canopy_short)
# Create a regression model
M <- lm(lag.canopy.short ~ Canopy_short, fixed_field_data_processed_NN_UTM)
# Plot the lagged variable vs. the variable
ggplot(data=fixed_field_data_processed_NN_UTM, aes(x=Canopy_short, y=lag.canopy.short))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Short Canopy Axis")+
ylab("Lagged Short Canopy Axis")
MC_local <- localmoran_perm(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 9999)
MC_local
MC_local <- localmoran_perm(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 9999)
MC_local.df <- as.data.frame(MC_local)
fixed_field_data_processed_NN_UTM$p  <- MC_local.df$`Pr(folded) Sim`
plot(fixed_field_data_processed_NN_UTM$p)
as.data.frame(MC_local)
MC_local.df$`Pr(folded) Sim`
fixed_field_data_processed_NN_UTM
fixed_field_data_processed_NN_UTM$p
fixed_field_data_processed_NN_UTM
View(fixed_field_data_processed_NN_UTM)
ggplot() +
geom_sf(data =fixed_field_data_processed_NN_UTM, aes(fill = p))
ggplot() +
geom_sf(data =fixed_field_data_processed_NN_UTM, aes(fill = p)) +
coord_sf(bbox(river_LM_trans))
bbox(river_LM_trans)
river_LM_trans
st_bbox(river_LM_trans)
ggplot() +
geom_sf(data =fixed_field_data_processed_NN_UTM, aes(fill = p)) +
coord_sf(st_bbox(river_LM_trans))
ggplot() +
geom_sf(river_LM_trans) +
geom_sf(data =fixed_field_data_processed_NN_UTM, aes(fill = p))
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =fixed_field_data_processed_NN_UTM, aes(fill = p))
LM_box <- st_bbox(river_LM_trans)
LM_box
LM_box[1]
xlim
?coord_sf
LM_box
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =fixed_field_data_processed_NN_UTM, aes(fill = p)) +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =fixed_field_data_processed_NN_UTM, aes(color = p)) +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn <- knearneigh(tree.coord.matrix, k = 5) #I have playing around with the k, trying to include all or half of the trees for example
#turns knn into neighbors list
nb <- knn2nb(knn, row.names = NULL, sym = FALSE)
#assigning weights to each neighbor, W style assigns weight to be 1/# of neighbors
lw <- nb2listw(nb,zero.policy=TRUE, style="W")
MC_local <- localmoran_perm(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 9999)
MC_local.df <- as.data.frame(MC_local)
fixed_field_data_processed_NN_UTM$p  <- MC_local.df$`Pr(folded) Sim`
LM_box <- st_bbox(river_LM_trans)
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =fixed_field_data_processed_NN_UTM, aes(color = p)) +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))
MC_local <- localmoran_perm(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 9999)
MC_local.df <- as.data.frame(MC_local)
MC_local.df
MC_local
plot(MC_local)
moran.plot(MC_local)
moran.plot(MC_local, lw)
MC_local <- localmoran_perm(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 9999)
MC_local <- localmoran_perm(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 9999, alternative = "greater")
plot(MC_local)
MC_local.df <- as.data.frame(MC_local)
fixed_field_data_processed_NN_UTM$p  <- MC_local.df$`Pr(folded) Sim`
MC_local <- localmoran_perm(fixed_field_data_processed_NN_UTM$Canopy_short, lw, nsim = 9999, alternative = "greater")
moran.plot(MC_local)
#turning river polygon into multipoints and then into a raster for using them to calculate the distances
river_SD_trans_points <- st_cast(river_SD_trans, "MULTIPOINT") #turns the polyline of the river into a multipoint object
river_SD_trans_point_raster <- st_rasterize(river_SD_trans_points) #create raster of lake edge points
plot(river_SD_trans_point_raster)
river_buffer_SD_points <- st_cast(river_buffer_SD, "MULTIPOINT") #turns the polyline of the river buffer into a multipoint object
river_buffer_SD_point_raster <- st_rasterize(river_buffer_SD_points) #create raster of lake edge points
plot(river_buffer_SD_point_raster)
#making a stars object of the distances of each cell in the buffer raster from the river edge points
river_buffer_SD_point_raster[is.na(river_buffer_SD_point_raster[])] <- 0  #making sure the points that are not the river buffer have a 0 value
dist_near_river_buffer_SD <- dist_to_nearest(river_buffer_SD_point_raster, river_SD_trans_points, progress = T) #creating a raster of the distances of each cell in the buffer raster to the multipoints on the river polygon, this took an hour to run
dist_near_river_buffer_SD_inverse <- 1/dist_near_river_buffer_SD #creating the inverse of the distance raster so that the higher values are closer to the river and the values are between 0-1
plot(dist_near_river_buffer_SD_inverse)
#creating a raster with assigned values of 1 to cells within 30 m of the river edge and 1/distance to the cells outside to turn the distances into values 0-1
dist_near_river_buffer_SD_inverse <- dist_near_river_buffer_SD %>% #creating a new stars object with new defined values for distance
st_as_sf() %>% #converting the stars to a shapefile
mutate(d = case_when(d <= 60 ~ 1,
d > 1 ~ 1/d)) %>% #assigning cells less than 30 m away from rivers edge with value of 1 and taking 1/distance for all other cells
st_rasterize() #convert the shapefile into a raster
plot(dist_near_river_buffer_SD_inverse)
#assigning average nearest neighbor values for the entire population of trees
ann.p_SD <- mean(nndist(SD_ppp, k=1))
ann.p_SD
#simulation to create a list of ANN from randomly placed points
n <- 566L #defines the number of simulations
ann.r <- vector(length = n) #creates the empty object that we can store ANN values in
for (i in 1:n){
rand.p <- rpoint(n=length(SD_fixed_field_data_processed_sf), win = river_SD_convex_hull) #river_buffer_LM  #river_LM_trans. #river_LM_convex_hull
ann.r[i] <- mean(nndist(rand.p, k=1)) #for each simulated random distribution of points it calculates the mean ANN across all of the trees
} #for the length of the number of points at LM, it assigns a random point within the convex hull window
plot(rand.p)
#creating a histogram of the ANN Simulation Results
as_tibble(ann.r) %>%  #turns the list of ann values from the simulations of random points and turns it into a tibble/dataframe
ggplot()+
geom_histogram(aes(x = value), fill = "dodgerblue1", color = "black", bins = 50) +
xlim(range(ann.p, ann.r)) + #sets the limit of the xaxis to encompass the ANN for our trees and histogram of ANNs from the simulation
geom_vline(xintercept=ann.p, col = "red") + #adds a verticle line of our tree'\s' ANN
xlab("ANN")+
theme_classic()
ggplot()+
geom_sf(data=rand.p)+
geom_points(data=SD_fixed_field_data_processed_sf)
rand.p
ggplot()+
geom_sf(data=st_as_sf(rand.p))+
geom_points(data=SD_fixed_field_data_processed_sf)
ggplot()+
geom_sf(data=st_as_sf(rand.p))+
geom_point(data=SD_fixed_field_data_processed_sf)
#adding the UTM 12 crs to rand.p
rand.p.crs <- rand.p %>%
st_as_sf()%>%
st_set_crs(26912)
#plotting the randomly generated points, tree points, and probability/distance raster
ggplot()+
geom_stars(data=river_SD_trans)+ #plotting the river edge raster
geom_sf(data=SD_fixed_field_data_processed_sf, aes(col = "red"))+ #plotting the tree points
geom_sf(data=rand.p.crs, fill = NA) #plotting the random points
#plotting the randomly generated points, tree points, and probability/distance raster
ggplot()+
geom_sf(data=river_SD_trans)+ #plotting the river edge raster
geom_sf(data=SD_fixed_field_data_processed_sf, aes(col = "red"))+ #plotting the tree points
geom_sf(data=rand.p.crs, fill = NA) #plotting the random points
#creating a histogram of the ANN Simulation Results
as_tibble(ann.r) %>%  #turns the list of ann values from the simulations of random points and turns it into a tibble/dataframe
ggplot()+
geom_histogram(aes(x = value), fill = "dodgerblue1", color = "black", bins = 50) +
xlim(range(ann.p, ann.r)) + #sets the limit of the xaxis to encompass the ANN for our trees and histogram of ANNs from the simulation
geom_vline(xintercept=ann.p, col = "red") + #adds a verticle line of our tree'\s' ANN
xlab("ANN")+
theme_classic()
#ANN analysis controlling for river
n <- 599L #defines the number of simulations
ann.r <- vector(length = n) #creates the empty object that we can store ANN values in
for (i in 1:n){
rand.p <- rpoint(n=length(SD_fixed_field_data_processed_sf), f = as.im(river_SD_trans_point_raster))
ann.r[i] <- mean(nndist(rand.p, k=1)) #for each simulated random distribution of points it calculates the mean ANN across all of the trees
} #for the length of the number of points at LM, it assigns a random point on top of the river's edge while controlling for the river's edge
#ANN analysis controlling for river
n <- 599L #defines the number of simulations
ann.r <- vector(length = n) #creates the empty object that we can store ANN values in
for (i in 1:n){
rand.p <- rpoint(n=length(SD_fixed_field_data_processed_sf), f = as.im(river_SD_trans_point_raster))
ann.r[i] <- mean(nndist(rand.p, k=1)) #for each simulated random distribution of points it calculates the mean ANN across all of the trees
} #for the length of the number of points at LM, it assigns a random point on top of the river's edge while controlling for the river's edge
library(tidyverse)
library(moments) # for calculating the moments of each variable
library(sf) # for plotting spatial objects
library(smatr)
library(ggpmisc)
library(PMCMRplus) # for Dunn test
library(geomtextpath) # for PCA graphing
library(spatstat) # to run the Ripley's K function: Kest
library(stars) # for sf_rasterize function
library(raster) #to use crop
library(starsExtra) #to use dist_to_nearest
library(geostatsp)
library(tmaptools)
fixed_field_data_processed <- read.csv("./analyses/fixed_field_data_processed.csv") #imports the csv created from analyzing_morpho_data_cleaned.R
#upload river shapefile and filter out polygons for each population
rivers <- st_read("./data/QUBR Rivers and Trees.kml", "Rivers", crs = 4326)
rivers_2d <- st_zm(rivers, drop = T) #we had a z dimension with max and min, so we got rid of it because it was giving us weird errors and disrupting later statistics
river_LC <- filter(rivers_2d, Name == "River LC")
river_SD <- filter(rivers_2d, Name == "River SD")
river_LM <- filter(rivers_2d, Name == "LM River")
#changing the coordinate reference system of the river polygons to be equal area projection (UTM 12N), uses meters as distance measurement
river_LM_trans <- st_transform(river_LM, crs = 26912)
river_LC_trans <- st_transform(river_LC, crs = 26912)
river_SD_trans <- st_transform(river_SD, crs = 26912)
river_buffer_LM<- st_buffer(river_LM_trans, 200) #200 m buffer
ggplot(river_buffer_LM)+
geom_sf()
river_buffer_LC<- st_buffer(river_LC_trans, 230) #230 m buffer
ggplot(river_buffer_LC)+
geom_sf()
river_buffer_SD<- st_buffer(river_SD_trans, 120) #120 m buffer
ggplot(river_buffer_SD)+
geom_sf()
LM_fixed_field_data_processed <- fixed_field_data_processed %>%
filter(Locality == "LM")
LC_fixed_field_data_processed <- fixed_field_data_processed %>%
filter(Locality == "LC")
SD_fixed_field_data_processed <- fixed_field_data_processed %>%
filter(Locality == "SD")
#ANN analysis controlling for river
n <- 599L #defines the number of simulations
ann.r <- vector(length = n) #creates the empty object that we can store ANN values in
for (i in 1:n){
rand.p <- rpoint(n=length(SD_fixed_field_data_processed_sf),
f = as.im(dist_near_river_buffer_SD_inverse)) #dist_near_river_buffer_LM_inverse #forcewin = T, win=as.owin(river_LM_convex_hull)
ann.r[i] <- mean(nndist(rand.p, k=1)) #for each simulated random distribution of points it calculates the mean ANN across all of the trees
} #for the length of the number of points at LM, it assigns a random point within the distance raster while controlling for distance to the river's edge
