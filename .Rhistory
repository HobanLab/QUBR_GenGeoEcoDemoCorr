#using the weighted neighbors to simulate size values
MC_local.LC.canopy.long <- locaLCoran_perm(LC_fixed_field_data_processed$Canopy_long, lw.LC, nsim = 9999, alternative = "greater")
#using the weighted neighbors to simulate size values
MC_local.LC.canopy.long <- localmoran_perm(LC_fixed_field_data_processed$Canopy_long, lw.LC, nsim = 9999, alternative = "greater")
MC_local.LC.canopy.long.df <- as.data.frame(MC_local.LC.canopy.long)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.LC.canopy.long.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Long Canopy Axis")+
ylab("Expected Moran's I Statistic for Long Canopy Axis")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
LC_fixed_field_data_processed$p.canopy.long  <- MC_local.LC.canopy.long.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
LC_fixed_field_data_processed$p.canopy.long.adjusted <- p.adjust(LC_fixed_field_data_processed$p.canopy.long,
method = "fdr", n=length(LC_fixed_field_data_processed$p.canopy.long))
#representing the p-values of the points on a map
LC_box <- st_bbox(river_LC_trans)
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Values for LCA")
#computing the Global Moran's I statistic
Moran.I(LC_fixed_field_data_processed$Crown_spread, LC.tree.dist.inv)
#representing the p-values of the points on a map
LC_box <- st_bbox(river_LC_trans)
LC_fixed_field_data_processed <- LC_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.long.adjusted <= .05)
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
geom_sf(data = LC_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for SCA")
#computing the Global Moran's I statistic
Moran.I(LC_fixed_field_data_processed$Crown_spread, LC.tree.dist.inv)
#computing the Global Moran's I statistic
Moran.I(LC_fixed_field_data_processed$Crown_spread, LC.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
LC_fixed_field_data_processed$lag.crown.spread <- lag.listw(lw.LC, LC_fixed_field_data_processed$Crown_spread)
# Create a regression model
M.LC.crown.spread <- LC(lag.crown.spread ~ Crown_spread, LC_fixed_field_data_processed)
# Create a regression model
M.LC.crown.spread <- lm(lag.crown.spread ~ Crown_spread, LC_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=LC_fixed_field_data_processed, aes(x=Crown_spread, y=lag.crown.spread))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Crown Spread")+
ylab("Lagged Crown Spread")
#computing the Moran's I statistic
moran(LC_fixed_field_data_processed$Crown_spread, listw = lw.LC, n = length(nb.LC), S0 = Szero(lw.LC))
#assessing statistical significance with a Monte-Carlo simulation
MC.LC.crown.spread <- moran.mc(LC_fixed_field_data_processed$Crown_spread, lw.LC, nsim = 999)
MC.LC.crown.spread
#plot of simulated Moran's I values against our value
plot(MC.LC.crown.spread, main="", las=1, xlab = "Crown Spread")
MC.LC.crown.spread$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.LC.crown.spread <- locaLCoran_perm(LC_fixed_field_data_processed$Crown_spread, lw.LC, nsim = 9999, alternative = "greater")
#using the weighted neighbors to simulate size values
MC_local.LC.crown.spread <- localmoran_perm(LC_fixed_field_data_processed$Crown_spread, lw.LC, nsim = 9999, alternative = "greater")
MC_local.LC.crown.spread.df <- as.data.frame(MC_local.LC.crown.spread)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.LC.crown.spread.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Crown Spread")+
ylab("Expected Moran's I Statistic for Crown Spread")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
LC_fixed_field_data_processed$p.crown.spread  <- MC_local.LC.crown.spread.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
LC_fixed_field_data_processed$p.crown.spread.adjusted <- p.adjust(LC_fixed_field_data_processed$p.crown.spread,
method = "fdr", n=length(LC_fixed_field_data_processed$p.crown.spread))
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.crown.spread.adjusted)) +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for Crown Spread")
LC_box <- st_bbox(river_LC_trans)
LC_fixed_field_data_processed <- LC_fixed_field_data_processed %>%
mutate(pval_sig = p.crown.spread.adjusted <= .05)
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.crown.spread.adjusted)) +
geom_sf(data = LC_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for SCA")
#computing the Global Moran's I statistic
Moran.I(LC_fixed_field_data_processed$Canopy_area, LC.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
LC_fixed_field_data_processed$lag.canopy.area <- lag.listw(lw.LC, LC_fixed_field_data_processed$Canopy_area)
# Create a regression model
M.LC.canopy.area <- LC(lag.canopy.area ~ Canopy_area, LC_fixed_field_data_processed)
#creating lags, which computes the average neighboring short canopy axis for each tree
LC_fixed_field_data_processed$lag.canopy.area <- lag.listw(lw.LC, LC_fixed_field_data_processed$Canopy_area)
# Create a regression model
M.LC.canopy.area <- lm(lag.canopy.area ~ Canopy_area, LC_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=LC_fixed_field_data_processed, aes(x=Canopy_area, y=lag.canopy.area))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Canopy Area")+
ylab("Lagged Canopy Area")
#computing the Moran's I statistic
moran(LC_fixed_field_data_processed$Canopy_area, listw = lw.LC, n = length(nb.LC), S0 = Szero(lw.LC))
#assessing statistical significance with a Monte-Carlo simulation
MC.LC.canopy.area <- moran.mc(LC_fixed_field_data_processed$Canopy_area, lw.LC, nsim = 999)
MC.LC.canopy.area
#plot of simulated Moran's I values against our value
plot(MC.LC.canopy.area, main="", las=1, xlab = "Canopy Area")
MC.LC.canopy.area$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.LC.canopy.area <- localmoran_perm(LC_fixed_field_data_processed$Canopy_area, lw.LC, nsim = 9999, alternative = "greater")
MC_local.LC.canopy.area.df <- as.data.frame(MC_local.LC.canopy.area)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.LC.canopy.area.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Canopy Area")+
ylab("Expected Moran's I Statistic for Canopy Area")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
LC_fixed_field_data_processed$p.canopy.area <- MC_local.LC.canopy.area.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
LC_fixed_field_data_processed$p.canopy.area.adjusted <- p.adjust(LC_fixed_field_data_processed$p.canopy.area,
method = "fdr", n=length(LC_fixed_field_data_processed$p.canopy.area))
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.canopy.area.adjusted)) +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for Canopy Area")
LC_box <- st_bbox(river_LC_trans)
LC_fixed_field_data_processed <- LC_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.area.adjusted <= .05)
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.canopy.area.adjusted)) +
geom_sf(data = LC_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for SCA")
#computing the Global Moran's I statistic
Moran.I(LC_fixed_field_data_processed$DBH_ag, LC.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
LC_fixed_field_data_processed$lag.dbh.ag <- lag.listw(lw.LC, LC_fixed_field_data_processed$DBH_ag)
# Create a regression model
M.LC.canopy.area <- lm(lag.dbh.ag ~ DBH_ag, LC_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=LC_fixed_field_data_processed, aes(x=DBH_ag, y=lag.dbh.ag))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("DBH")+
ylab("Lagged DBH")
#computing the Moran's I statistic
moran(LC_fixed_field_data_processed$DBH_ag, listw = lw.LC, n = length(nb.LC), S0 = Szero(lw.LC))
#assessing statistical significance with a Monte-Carlo simulation
MC.LC.dbh.ag <- moran.mc(LC_fixed_field_data_processed$DBH_ag, lw.LC, nsim = 999)
MC.LC.dbh.ag
#plot of simulated Moran's I values against our value
plot(MC.LC.dbh.ag, main="", las=1, xlab = "DBH")
MC.LC.dbh.ag$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.LC.dbh.ag <- locaLCoran_perm(LC_fixed_field_data_processed$DBH_ag, lw.LC, nsim = 9999, alternative = "greater")
MC_local.LC.dbh.ag.df <- as.data.frame(MC_local.LC.dbh.ag)
#using the weighted neighbors to simulate size values
MC_local.LC.dbh.ag <- localmoran_perm(LC_fixed_field_data_processed$DBH_ag, lw.LC, nsim = 9999, alternative = "greater")
MC_local.LC.dbh.ag.df <- as.data.frame(MC_local.LC.dbh.ag)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.LC.dbh.ag.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for DBH")+
ylab("Expected Moran's I Statistic for DBH")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
LC_fixed_field_data_processed$p.dbh.ag <- MC_local.LC.dbh.ag.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
LC_fixed_field_data_processed$p.dbh.ag.adjusted <- p.adjust(LC_fixed_field_data_processed$p.dbh.ag,
method = "fdr", n=length(LC_fixed_field_data_processed$p.dbh.ag))
#representing the p-values of the points on a map
LC_box <- st_bbox(river_LC_trans)
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.dbh.ag.adjusted)) +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for DBH")
#representing the p-values of the points on a map
LC_box <- st_bbox(river_LC_trans)
LC_fixed_field_data_processed <- LC_fixed_field_data_processed %>%
mutate(pval_sig = p.dbh.ag.adjusted <= .05)
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.dbh.ag.adjusted)) +
geom_sf(data = LC_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for CA")
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Values for LCA")
LM_box <- st_bbox(river_LM_trans)
LM_fixed_field_data_processed <- LM_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.long.adjusted <= .05)
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
geom_sf(data = LM_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Value for SCA")
#representing the p-values of the points on a map
LM_box <- st_bbox(river_LM_trans)
LM_fixed_field_data_processed <- LM_fixed_field_data_processed %>%
mutate(pval_sig = p.crown.spread.adjusted <= .05)
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.crown.spread.adjusted)) +
geom_sf(data = LM_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Value for CS")
#representing the p-values of the points on a map
LM_box <- st_bbox(river_LM_trans)
LM_fixed_field_data_processed <- LM_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.area.adjusted <= .05)
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.canopy.area.adjusted)) +
geom_sf(data = LM_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Value for CA")
#representing the p-values of the points on a map
LM_box <- st_bbox(river_LM_trans)
LM_fixed_field_data_processed <- LM_fixed_field_data_processed %>%
mutate(pval_sig = p.dbh.ag.adjusted <= .05)
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.dbh.ag.adjusted)) +
geom_sf(data = LM_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Value for DBH")
#creating a matrix of distances between trees where the higher values are at the top
SD.tree.dist <- as.matrix(dist(cbind(SD_fixed_field_data_processed$X.1,
SD_fixed_field_data_processed$Y))) #making a matrix of the distances between trees
SD.tree.dist.inv <- 1/SD.tree.dist #makes it so closer trees are higher in the matrix
diag(SD.tree.dist.inv) <- 0 #makes so trees have a 0 distance with themselves
SD.tree.dist.inv[is.infinite(SD.tree.dist.inv)] <- 0 # solves problem presented by duplicated GPS points for trees that were very close to one another
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Canopy_short, SD.tree.dist.inv)
SD.tree.coord.matrix <- as.matrix(cbind(SD_fixed_field_data_processed$X.1,
SD_fixed_field_data_processed$Y))
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn.SD <- knearneigh(SD.tree.coord.matrix, k = 5, longlat = F) #I have playing around with the k, trying to include all or half of the trees for example
#turns knn into neighbors list
nb.SD <- knn2nb(knn.SD, row.names = NULL, sym = FALSE)
#assigning weights to each neighbor, W style assigns weight to be 1/# of neighbors
#lw <- nb2listw(nb,zero.policy=TRUE, style="W")
#inverse distance weighting with raw distance-based weights without applying any normalisation
lw.SD <- nb2listwdist(nb.SD, SD_fixed_field_data_processed, type="idw", style="W",
alpha = 1, dmax = NULL, longlat = F, zero.policy=NULL) #it converts it to latlon and then takes the distance because that is also more accurate
lw.SD$weights[[1]]
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.canopy.short <- lag.listw(lw.SD, SD_fixed_field_data_processed$Canopy_short)
# Create a regression model
M.SD <- lm(lag.canopy.short ~ Canopy_short, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Canopy_short, y=lag.canopy.short))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Short Canopy Axis")+
ylab("Lagged Short Canopy Axis")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Canopy_short, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.canopy.short <- moran.mc(SD_fixed_field_data_processed$Canopy_short, lw.SD, nsim = 999)
MC.SD.canopy.short
#plot of simulated Moran's I values against our value
plot(MC.SD.canopy.short, main="", las=1, xlab = "Short Canopy Axis")
MC.SD.canopy.short$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.canopy.short <- localmoran_perm(SD_fixed_field_data_processed$Canopy_short, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.canopy.short.df <- as.data.frame(MC_local.SD.canopy.short)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.canopy.short.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic")+
ylab("Expected Moran's I Statistic")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.canopy.short  <- MC_local.SD.canopy.short.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.canopy.short.adjusted <- p.adjust(SD_fixed_field_data_processed$p.canopy.short,
method = "fdr", n=length(SD_fixed_field_data_processed$p.canopy.short))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.short.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.canopy.short.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for SCA")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Canopy_long, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.canopy.long <- lag.listw(lw.SD, SD_fixed_field_data_processed$Canopy_long)
# Create a regression model
M.SD.Canopy.Long <- lm(lag.canopy.long ~ Canopy_long, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Canopy_long, y=lag.canopy.long))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Long Canopy Axis")+
ylab("Lagged Long Canopy Axis")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Canopy_long, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.canopy.long <- moran.mc(SD_fixed_field_data_processed$Canopy_long, lw.SD, nsim = 999)
MC.SD.canopy.long
#plot of simulated Moran's I values against our value
plot(MC.SD.canopy.long, main="", las=1, xlab = "Long Canopy Axis")
MC.SD.canopy.long$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.canopy.long <- localmoran_perm(SD_fixed_field_data_processed$Canopy_long, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.canopy.long.df <- as.data.frame(MC_local.SD.canopy.long)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.canopy.long.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Long Canopy Axis")+
ylab("Expected Moran's I Statistic for Long Canopy Axis")+
theme_gray()
#caSDulating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.canopy.long  <- MC_local.SD.canopy.long.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.canopy.long.adjusted <- p.adjust(SD_fixed_field_data_processed$p.canopy.long,
method = "fdr", n=length(SD_fixed_field_data_processed$p.canopy.long))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.long.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for SDA")
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for LCA")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Crown_spread, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.crown.spread <- lag.listw(lw.SD, SD_fixed_field_data_processed$Crown_spread)
# Create a regression model
M.SD.crown.spread <- lm(lag.crown.spread ~ Crown_spread, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Crown_spread, y=lag.crown.spread))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Crown Spread")+
ylab("Lagged Crown Spread")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Crown_spread, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.crown.spread <- moran.mc(SD_fixed_field_data_processed$Crown_spread, lw.SD, nsim = 999)
MC.SD.crown.spread
#plot of simulated Moran's I values against our value
plot(MC.SD.crown.spread, main="", las=1, xlab = "Crown Spread")
MC.SD.crown.spread$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.crown.spread <- localmoran_perm(SD_fixed_field_data_processed$Crown_spread, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.crown.spread.df <- as.data.frame(MC_local.SD.crown.spread)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.crown.spread.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Crown Spread")+
ylab("Expected Moran's I Statistic for Crown Spread")+
theme_gray()
#caSDulating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.crown.spread  <- MC_local.SD.crown.spread.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.crown.spread.adjusted <- p.adjust(SD_fixed_field_data_processed$p.crown.spread,
method = "fdr", n=length(SD_fixed_field_data_processed$p.crown.spread))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.crown.spread.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.crown.spread.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for CS")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Canopy_area, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.canopy.area <- lag.listw(lw.SD, SD_fixed_field_data_processed$Canopy_area)
# Create a regression model
M.SD.canopy.area <- lm(lag.canopy.area ~ Canopy_area, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Canopy_area, y=lag.canopy.area))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Canopy Area")+
ylab("Lagged Canopy Area")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Canopy_area, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.canopy.area <- moran.mc(SD_fixed_field_data_processed$Canopy_area, lw.SD, nsim = 999)
MC.SD.canopy.area
#plot of simulated Moran's I values against our value
plot(MC.SD.canopy.area, main="", las=1, xlab = "Canopy Area")
MC.SD.canopy.area$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.canopy.area <- localmoran_perm(SD_fixed_field_data_processed$Canopy_area, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.canopy.area.df <- as.data.frame(MC_local.SD.canopy.area)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.canopy.area.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Canopy Area")+
ylab("Expected Moran's I Statistic for Canopy Area")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.canopy.area <- MC_local.SD.canopy.area.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.canopy.area.adjusted <- p.adjust(SD_fixed_field_data_processed$p.canopy.area,
method = "fdr", n=length(SD_fixed_field_data_processed$p.canopy.area))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.area.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.canopy.area.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for CA")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$DBH_ag, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.dbh.ag <- lag.listw(lw.SD, SD_fixed_field_data_processed$DBH_ag)
# Create a regression model
M.SD.canopy.area <- lm(lag.dbh.ag ~ DBH_ag, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=DBH_ag, y=lag.dbh.ag))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("DBH")+
ylab("Lagged DBH")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$DBH_ag, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.dbh.ag <- moran.mc(SD_fixed_field_data_processed$DBH_ag, lw.SD, nsim = 999)
MC.SD.dbh.ag
#plot of simulated Moran's I values against our value
plot(MC.SD.dbh.ag, main="", las=1, xlab = "DBH")
MC.SD.dbh.ag$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.dbh.ag <- localmoran_perm(SD_fixed_field_data_processed$DBH_ag, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.dbh.ag.df <- as.data.frame(MC_local.SD.dbh.ag)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.dbh.ag.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for DBH")+
ylab("Expected Moran's I Statistic for DBH")+
theme_gray()
#caSDulating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.dbh.ag <- MC_local.SD.dbh.ag.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.dbh.ag.adjusted <- p.adjust(SD_fixed_field_data_processed$p.dbh.ag,
method = "fdr", n=length(SD_fixed_field_data_processed$p.dbh.ag))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.dbh.ag.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.dbh.ag.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for CA")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Canopy_area, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.canopy.area <- lag.listw(lw.SD, SD_fixed_field_data_processed$Canopy_area)
# Create a regression model
M.SD.canopy.area <- lm(lag.canopy.area ~ Canopy_area, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Canopy_area, y=lag.canopy.area))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Canopy Area")+
ylab("Lagged Canopy Area")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Canopy_area, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.canopy.area <- moran.mc(SD_fixed_field_data_processed$Canopy_area, lw.SD, nsim = 999)
MC.SD.canopy.area
#plot of simulated Moran's I values against our value
plot(MC.SD.canopy.area, main="", las=1, xlab = "Canopy Area")
MC.SD.canopy.area$p.value #extracting the pvalue
