#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.LC.canopy.area.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Canopy Area")+
ylab("Expected Moran's I Statistic for Canopy Area")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
LC_fixed_field_data_processed$p.canopy.area <- MC_local.LC.canopy.area.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
LC_fixed_field_data_processed$p.canopy.area.adjusted <- p.adjust(LC_fixed_field_data_processed$p.canopy.area,
method = "fdr", n=length(LC_fixed_field_data_processed$p.canopy.area))
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.canopy.area.adjusted)) +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for Canopy Area")
LC_box <- st_bbox(river_LC_trans)
LC_fixed_field_data_processed <- LC_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.area.adjusted <= .05)
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.canopy.area.adjusted)) +
geom_sf(data = LC_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for SCA")
#computing the Global Moran's I statistic
Moran.I(LC_fixed_field_data_processed$DBH_ag, LC.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
LC_fixed_field_data_processed$lag.dbh.ag <- lag.listw(lw.LC, LC_fixed_field_data_processed$DBH_ag)
# Create a regression model
M.LC.canopy.area <- lm(lag.dbh.ag ~ DBH_ag, LC_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=LC_fixed_field_data_processed, aes(x=DBH_ag, y=lag.dbh.ag))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("DBH")+
ylab("Lagged DBH")
#computing the Moran's I statistic
moran(LC_fixed_field_data_processed$DBH_ag, listw = lw.LC, n = length(nb.LC), S0 = Szero(lw.LC))
#assessing statistical significance with a Monte-Carlo simulation
MC.LC.dbh.ag <- moran.mc(LC_fixed_field_data_processed$DBH_ag, lw.LC, nsim = 999)
MC.LC.dbh.ag
#plot of simulated Moran's I values against our value
plot(MC.LC.dbh.ag, main="", las=1, xlab = "DBH")
MC.LC.dbh.ag$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.LC.dbh.ag <- locaLCoran_perm(LC_fixed_field_data_processed$DBH_ag, lw.LC, nsim = 9999, alternative = "greater")
MC_local.LC.dbh.ag.df <- as.data.frame(MC_local.LC.dbh.ag)
#using the weighted neighbors to simulate size values
MC_local.LC.dbh.ag <- localmoran_perm(LC_fixed_field_data_processed$DBH_ag, lw.LC, nsim = 9999, alternative = "greater")
MC_local.LC.dbh.ag.df <- as.data.frame(MC_local.LC.dbh.ag)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.LC.dbh.ag.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for DBH")+
ylab("Expected Moran's I Statistic for DBH")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
LC_fixed_field_data_processed$p.dbh.ag <- MC_local.LC.dbh.ag.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
LC_fixed_field_data_processed$p.dbh.ag.adjusted <- p.adjust(LC_fixed_field_data_processed$p.dbh.ag,
method = "fdr", n=length(LC_fixed_field_data_processed$p.dbh.ag))
#representing the p-values of the points on a map
LC_box <- st_bbox(river_LC_trans)
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.dbh.ag.adjusted)) +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for DBH")
#representing the p-values of the points on a map
LC_box <- st_bbox(river_LC_trans)
LC_fixed_field_data_processed <- LC_fixed_field_data_processed %>%
mutate(pval_sig = p.dbh.ag.adjusted <= .05)
ggplot() +
geom_sf(data =river_LC_trans) +
geom_sf(data =LC_fixed_field_data_processed, aes(color = p.dbh.ag.adjusted)) +
geom_sf(data = LC_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LC_box[1], LC_box[3]), ylim = c(LC_box[2], LC_box[4]))+
labs(color = "Adjusted P Value for CA")
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Values for LCA")
LM_box <- st_bbox(river_LM_trans)
LM_fixed_field_data_processed <- LM_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.long.adjusted <= .05)
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
geom_sf(data = LM_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Value for SCA")
#representing the p-values of the points on a map
LM_box <- st_bbox(river_LM_trans)
LM_fixed_field_data_processed <- LM_fixed_field_data_processed %>%
mutate(pval_sig = p.crown.spread.adjusted <= .05)
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.crown.spread.adjusted)) +
geom_sf(data = LM_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Value for CS")
#representing the p-values of the points on a map
LM_box <- st_bbox(river_LM_trans)
LM_fixed_field_data_processed <- LM_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.area.adjusted <= .05)
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.canopy.area.adjusted)) +
geom_sf(data = LM_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Value for CA")
#representing the p-values of the points on a map
LM_box <- st_bbox(river_LM_trans)
LM_fixed_field_data_processed <- LM_fixed_field_data_processed %>%
mutate(pval_sig = p.dbh.ag.adjusted <= .05)
ggplot() +
geom_sf(data =river_LM_trans) +
geom_sf(data =LM_fixed_field_data_processed, aes(color = p.dbh.ag.adjusted)) +
geom_sf(data = LM_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(LM_box[1], LM_box[3]), ylim = c(LM_box[2], LM_box[4]))+
labs(color = "Adjusted P Value for DBH")
#creating a matrix of distances between trees where the higher values are at the top
SD.tree.dist <- as.matrix(dist(cbind(SD_fixed_field_data_processed$X.1,
SD_fixed_field_data_processed$Y))) #making a matrix of the distances between trees
SD.tree.dist.inv <- 1/SD.tree.dist #makes it so closer trees are higher in the matrix
diag(SD.tree.dist.inv) <- 0 #makes so trees have a 0 distance with themselves
SD.tree.dist.inv[is.infinite(SD.tree.dist.inv)] <- 0 # solves problem presented by duplicated GPS points for trees that were very close to one another
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Canopy_short, SD.tree.dist.inv)
SD.tree.coord.matrix <- as.matrix(cbind(SD_fixed_field_data_processed$X.1,
SD_fixed_field_data_processed$Y))
#creates nearest neighbor knn using a matrix of the tree coordinates and k = 1, means the distance to the nearbor is conputed only for the nearest one
knn.SD <- knearneigh(SD.tree.coord.matrix, k = 5, longlat = F) #I have playing around with the k, trying to include all or half of the trees for example
#turns knn into neighbors list
nb.SD <- knn2nb(knn.SD, row.names = NULL, sym = FALSE)
#assigning weights to each neighbor, W style assigns weight to be 1/# of neighbors
#lw <- nb2listw(nb,zero.policy=TRUE, style="W")
#inverse distance weighting with raw distance-based weights without applying any normalisation
lw.SD <- nb2listwdist(nb.SD, SD_fixed_field_data_processed, type="idw", style="W",
alpha = 1, dmax = NULL, longlat = F, zero.policy=NULL) #it converts it to latlon and then takes the distance because that is also more accurate
lw.SD$weights[[1]]
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.canopy.short <- lag.listw(lw.SD, SD_fixed_field_data_processed$Canopy_short)
# Create a regression model
M.SD <- lm(lag.canopy.short ~ Canopy_short, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Canopy_short, y=lag.canopy.short))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Short Canopy Axis")+
ylab("Lagged Short Canopy Axis")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Canopy_short, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.canopy.short <- moran.mc(SD_fixed_field_data_processed$Canopy_short, lw.SD, nsim = 999)
MC.SD.canopy.short
#plot of simulated Moran's I values against our value
plot(MC.SD.canopy.short, main="", las=1, xlab = "Short Canopy Axis")
MC.SD.canopy.short$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.canopy.short <- localmoran_perm(SD_fixed_field_data_processed$Canopy_short, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.canopy.short.df <- as.data.frame(MC_local.SD.canopy.short)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.canopy.short.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic")+
ylab("Expected Moran's I Statistic")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.canopy.short  <- MC_local.SD.canopy.short.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.canopy.short.adjusted <- p.adjust(SD_fixed_field_data_processed$p.canopy.short,
method = "fdr", n=length(SD_fixed_field_data_processed$p.canopy.short))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.short.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.canopy.short.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for SCA")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Canopy_long, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.canopy.long <- lag.listw(lw.SD, SD_fixed_field_data_processed$Canopy_long)
# Create a regression model
M.SD.Canopy.Long <- lm(lag.canopy.long ~ Canopy_long, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Canopy_long, y=lag.canopy.long))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Long Canopy Axis")+
ylab("Lagged Long Canopy Axis")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Canopy_long, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.canopy.long <- moran.mc(SD_fixed_field_data_processed$Canopy_long, lw.SD, nsim = 999)
MC.SD.canopy.long
#plot of simulated Moran's I values against our value
plot(MC.SD.canopy.long, main="", las=1, xlab = "Long Canopy Axis")
MC.SD.canopy.long$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.canopy.long <- localmoran_perm(SD_fixed_field_data_processed$Canopy_long, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.canopy.long.df <- as.data.frame(MC_local.SD.canopy.long)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.canopy.long.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Long Canopy Axis")+
ylab("Expected Moran's I Statistic for Long Canopy Axis")+
theme_gray()
#caSDulating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.canopy.long  <- MC_local.SD.canopy.long.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.canopy.long.adjusted <- p.adjust(SD_fixed_field_data_processed$p.canopy.long,
method = "fdr", n=length(SD_fixed_field_data_processed$p.canopy.long))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.long.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for SDA")
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.canopy.long.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for LCA")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Crown_spread, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.crown.spread <- lag.listw(lw.SD, SD_fixed_field_data_processed$Crown_spread)
# Create a regression model
M.SD.crown.spread <- lm(lag.crown.spread ~ Crown_spread, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Crown_spread, y=lag.crown.spread))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Crown Spread")+
ylab("Lagged Crown Spread")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Crown_spread, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.crown.spread <- moran.mc(SD_fixed_field_data_processed$Crown_spread, lw.SD, nsim = 999)
MC.SD.crown.spread
#plot of simulated Moran's I values against our value
plot(MC.SD.crown.spread, main="", las=1, xlab = "Crown Spread")
MC.SD.crown.spread$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.crown.spread <- localmoran_perm(SD_fixed_field_data_processed$Crown_spread, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.crown.spread.df <- as.data.frame(MC_local.SD.crown.spread)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.crown.spread.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Crown Spread")+
ylab("Expected Moran's I Statistic for Crown Spread")+
theme_gray()
#caSDulating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.crown.spread  <- MC_local.SD.crown.spread.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.crown.spread.adjusted <- p.adjust(SD_fixed_field_data_processed$p.crown.spread,
method = "fdr", n=length(SD_fixed_field_data_processed$p.crown.spread))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.crown.spread.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.crown.spread.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for CS")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Canopy_area, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.canopy.area <- lag.listw(lw.SD, SD_fixed_field_data_processed$Canopy_area)
# Create a regression model
M.SD.canopy.area <- lm(lag.canopy.area ~ Canopy_area, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Canopy_area, y=lag.canopy.area))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Canopy Area")+
ylab("Lagged Canopy Area")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Canopy_area, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.canopy.area <- moran.mc(SD_fixed_field_data_processed$Canopy_area, lw.SD, nsim = 999)
MC.SD.canopy.area
#plot of simulated Moran's I values against our value
plot(MC.SD.canopy.area, main="", las=1, xlab = "Canopy Area")
MC.SD.canopy.area$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.canopy.area <- localmoran_perm(SD_fixed_field_data_processed$Canopy_area, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.canopy.area.df <- as.data.frame(MC_local.SD.canopy.area)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.canopy.area.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for Canopy Area")+
ylab("Expected Moran's I Statistic for Canopy Area")+
theme_gray()
#calculating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.canopy.area <- MC_local.SD.canopy.area.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.canopy.area.adjusted <- p.adjust(SD_fixed_field_data_processed$p.canopy.area,
method = "fdr", n=length(SD_fixed_field_data_processed$p.canopy.area))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.canopy.area.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.canopy.area.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for CA")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$DBH_ag, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.dbh.ag <- lag.listw(lw.SD, SD_fixed_field_data_processed$DBH_ag)
# Create a regression model
M.SD.canopy.area <- lm(lag.dbh.ag ~ DBH_ag, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=DBH_ag, y=lag.dbh.ag))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("DBH")+
ylab("Lagged DBH")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$DBH_ag, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.dbh.ag <- moran.mc(SD_fixed_field_data_processed$DBH_ag, lw.SD, nsim = 999)
MC.SD.dbh.ag
#plot of simulated Moran's I values against our value
plot(MC.SD.dbh.ag, main="", las=1, xlab = "DBH")
MC.SD.dbh.ag$p.value #extracting the pvalue
#using the weighted neighbors to simulate size values
MC_local.SD.dbh.ag <- localmoran_perm(SD_fixed_field_data_processed$DBH_ag, lw.SD, nsim = 9999, alternative = "greater")
MC_local.SD.dbh.ag.df <- as.data.frame(MC_local.SD.dbh.ag)
##Ii is local moran statistic, E.Ii is expected local moran statistic, Vari.Ii is variance of local moran statistic, Z. Ii standard deviation of local moran statistic
#plotting the local moran's I values vs. the expected
ggplot(data=MC_local.SD.dbh.ag.df)+
geom_point(aes(x=Ii, y=E.Ii), size = 0.01)+
xlab("Local Moran's I Statistic for DBH")+
ylab("Expected Moran's I Statistic for DBH")+
theme_gray()
#caSDulating the p-values for each individual tree Moran's I, observed vs. expected
SD_fixed_field_data_processed$p.dbh.ag <- MC_local.SD.dbh.ag.df$`Pr(folded) Sim`
#adjusting the p-vlaues to take into account multiple tests
SD_fixed_field_data_processed$p.dbh.ag.adjusted <- p.adjust(SD_fixed_field_data_processed$p.dbh.ag,
method = "fdr", n=length(SD_fixed_field_data_processed$p.dbh.ag))
#representing the p-values of the points on a map
SD_box <- st_bbox(river_SD_trans)
SD_fixed_field_data_processed <- SD_fixed_field_data_processed %>%
mutate(pval_sig = p.dbh.ag.adjusted <= .05)
ggplot() +
geom_sf(data =river_SD_trans) +
geom_sf(data =SD_fixed_field_data_processed, aes(color = p.dbh.ag.adjusted)) +
geom_sf(data = SD_fixed_field_data_processed %>% filter(pval_sig == T), color = "red") +
coord_sf(xlim = c(SD_box[1], SD_box[3]), ylim = c(SD_box[2], SD_box[4]))+
labs(color = "Adjusted P Value for CA")
#computing the Global Moran's I statistic
Moran.I(SD_fixed_field_data_processed$Canopy_area, SD.tree.dist.inv)
#creating lags, which computes the average neighboring short canopy axis for each tree
SD_fixed_field_data_processed$lag.canopy.area <- lag.listw(lw.SD, SD_fixed_field_data_processed$Canopy_area)
# Create a regression model
M.SD.canopy.area <- lm(lag.canopy.area ~ Canopy_area, SD_fixed_field_data_processed)
# Plot the lagged variable vs. the variable
ggplot(data=SD_fixed_field_data_processed, aes(x=Canopy_area, y=lag.canopy.area))+
geom_point()+
geom_smooth(method = lm, col="blue")+
xlab("Canopy Area")+
ylab("Lagged Canopy Area")
#computing the Moran's I statistic
moran(SD_fixed_field_data_processed$Canopy_area, listw = lw.SD, n = length(nb.SD), S0 = Szero(lw.SD))
#assessing statistical significance with a Monte-Carlo simulation
MC.SD.canopy.area <- moran.mc(SD_fixed_field_data_processed$Canopy_area, lw.SD, nsim = 999)
MC.SD.canopy.area
#plot of simulated Moran's I values against our value
plot(MC.SD.canopy.area, main="", las=1, xlab = "Canopy Area")
MC.SD.canopy.area$p.value #extracting the pvalue
library(tidyverse)
library(moments) # for calculating the moments of each variable
library(sf) # for plotting spatial objects
library(smatr)
library(ggpmisc)
library(PMCMRplus) # for Dunn test
library(geomtextpath) # for PCA graphing
library(spatstat) # to run the nndist function
library(spdep) # to use morna's I functions like lag.listw
library(ape) # for computing the Moran's I stat
library(raster) #to use point distance
library(igraph) #to use create the overlaps between the buffers, find adjacencies, and find largest number of cliques
fixed_field_data_processed <- read.csv("./analyses/fixed_field_data_processed.csv") #imports the csv created from analyzing_morpho_data_cleaned.R
#transforming the data into shapefiles with either WGS84
fixed_field_data_processed_sf <- st_as_sf(fixed_field_data_processed,
coords = c("long", "lat"), crs = 4326)
#transforming the shapefile of trees from WGS84 into equal area projection UTM 12N
fixed_field_data_processed_sf_transformed <- st_transform(fixed_field_data_processed_sf, crs = 26912) # this in UTM 12 N an equal area projection
LM_fixed_field_data_processed_sf <- fixed_field_data_processed_sf_transformed %>%
filter(Locality == "LM") %>%
st_as_sfc()
LC_fixed_field_data_processed_sf <- fixed_field_data_processed_sf_transformed %>%
filter(Locality == "LC") %>%
st_as_sfc()
SD_fixed_field_data_processed_sf <- fixed_field_data_processed_sf_transformed %>%
filter(Locality == "SD") %>%
st_as_sfc()
#create dataframe with X and Y UTM coordinates
fixed_field_data_processed_sf_trans_coords <- st_coordinates(fixed_field_data_processed_sf_transformed) #creates a dataframe with seperate x and y columns from the UTM 12N transformation
fixed_field_data_processed_sf_trans_coordinates <- fixed_field_data_processed_sf_transformed %>%
cbind(fixed_field_data_processed_sf_trans_coords) #combines the x and y coordinate data frame with the transformed sf dataframe
#add average nearest neighbor for each individual column
fixed_field_data_processed_NN_UTM <- fixed_field_data_processed_sf_trans_coordinates %>%  #creates a dataframe with the ANN of the closest 5 individual trees for each individual
mutate(dist1 = nndist(X = X.1, Y= Y, k = 1))%>% #creates column for the distances of each tree to their 1st nearest neighbor
mutate(dist2 = nndist(X = X.1, Y= Y, k = 2)) %>% #creates column for the distances of each tree to their 2nd nearest neighbor
mutate(dist3 = nndist(X = X.1, Y= Y, k = 3)) %>% #creates column for the distances of each tree to their 3rd nearest neighbor
mutate(dist4 = nndist(X = X.1, Y= Y, k = 4)) %>% #creates column for the distances of each tree to their 4th nearest neighbor
mutate(dist5 = nndist(X = X.1, Y= Y, k = 5)) %>% #creates column for the distances of each tree to their 5th nearest neighbor
rowwise()%>% #so that in the next part we take the averages across rows
mutate(ANN = mean(c(dist1, dist2, dist3, dist4, dist5))) # %>% #creates a column of the average distances (1-5) of each individual
LM_fixed_field_data_processed <- fixed_field_data_processed_NN_UTM %>%
filter(Locality == "LM")
LC_fixed_field_data_processed <- fixed_field_data_processed_NN_UTM %>%
filter(Locality == "LC")
SD_fixed_field_data_processed <- fixed_field_data_processed_NN_UTM %>%
filter(Locality == "SD")
LM_tree_grid <- st_make_grid(cellsize = (((40*mean(LM_fixed_field_data_processed$DBH_ag))*2)*2))
LM_tree_grid <- st_make_grid(LM_fixed_field_data_processed_sf, cellsize = (((40*mean(LM_fixed_field_data_processed$DBH_ag))*2)*2))
plot(LM_tree_grid)
ggplot()+
geom_sf(data=LM_fixed_field_data_processed_sf)+
geom_sf(data=LM_tree_grid)
ggplot()+
geom_sf(data=LM_tree_grid)+
geom_sf(data=LM_fixed_field_data_processed_sf)
LM_tree_grid
st_within(LM_fixed_field_data_processed_sf, LM_tree_grid)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid)
LM_tree_grid_points_within
View(LM_tree_grid_points_within)
plot(LM_tree_grid_points_within)
plot(st_as_sf(LM_tree_grid_points_within))
length(LM_tree_grid)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[1])
selected_tree <- sample(LM_tree_grid_points_within, replace = F)
selected_tree
View(selected_tree)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[1])
selected_tree <- sample(LM_tree_grid_points_within, size = 1, replace = F)
View(selected_tree)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[1])
selected_tree <- sample(LM_tree_grid_points_within, size = 1, replace = F)
View(selected_tree)
LM_tree_grid[1]
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[2])
selected_tree <- sample(LM_tree_grid_points_within, size = 1, replace = F)
View(selected_tree)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[30])
selected_tree <- sample(LM_tree_grid_points_within, size = 1, replace = F)
View(selected_tree)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[15])
selected_tree <- sample(LM_tree_grid_points_within, size = 1, replace = F)
View(selected_tree)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[14])
selected_tree <- sample(LM_tree_grid_points_within, size = 1, replace = F)
View(selected_tree)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[13])
selected_tree <- sample(LM_tree_grid_points_within, size = 1, replace = F)
View(selected_tree)
length(LM_tree_grid_points_within)
selected_tree <- sample(LM_tree_grid_points_within, n = length(LM_tree_grid_points_within), size = 1, replace = F)
LM_tree_grid
LM_tree_grid_points_within
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_tree_grid[1], LM_fixed_field_data_processed_sf)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_tree_grid, LM_fixed_field_data_processed_sf)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_tree_grid, LM_fixed_field_data_processed_sf, sparse = T)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_tree_grid, LM_fixed_field_data_processed_sf, sparse = F)
LM_tree_grid_points_within <- st_within(LM_tree_grid[1], LM_fixed_field_data_processed_sf, sparse = F)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_tree_grid[15], LM_fixed_field_data_processed_sf, sparse = F)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[15], sparse = F)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[25], sparse = F)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[35], sparse = F)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[17], sparse = F)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[9], sparse = F)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[6], sparse = F)
View(LM_tree_grid_points_within)
LM_tree_grid_points_within <- st_within(LM_fixed_field_data_processed_sf, LM_tree_grid[163], sparse = F)
View(LM_tree_grid_points_within)
